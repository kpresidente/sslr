const archiveSet=()=>{return{save:async function(t,r){try{const a=FLD[t].Archives,n=await e(t,r),o=JSON.stringify({[a]:n}),c=await dp.table(t).key(r.id).update(o),i=n.map((async e=>dp.table(e.table).key(e.archived_record.id).delete()));return await Promise.allSettled(i),{archive:n,update:c,deletions:i}}catch(e){return MsgBox("There was an error archiving the record!",e.toString()),e}},get:e,restore:async function(e,t){try{Knack.showSpinner();const r=FLD[e].Archives,a=(t=await dp.table(e).key(t.id).getRecords().then((e=>e.data[0])))[r],n=JSON.parse(a);n=n.map((e=>(e=async function(e){try{const t=TBL[e.table],r=function(e,t){const r=["address","boolean","connection","currency","date_time","email","file","image","link","multiple_choice","name","number","paragraph_text","phone","rating","rich_text","signature","timer","user_roles"];delete t.id;const a=Object.entries(t).map((([e,t])=>[e,t,FLD[e].attributes.type])).filter((([e,t,a])=>r.includes(a))).map((([t,r,a])=>("connection"===a&&(r=[].concat(r).map((e=>e.id))),[t=FLD[e][t],r])));return Object.fromEntries(a)}(e.archived_record);return e.restored_record=await dp.table(t).create(r).then((e=>e.data[0])),e}catch(t){return e.error=t,Promise.reject(e)}}(e),e))),await Promise.allsettled(n),n=n.map((e=>("error"in e||(e=async function(e){try{const t=e.record.restored.id;e.connections=e.connections.map((e=>async function(e,t){const{foreign_table:r,foreign_field:a,foreign_id:n}=e;try{const o=TBL[r],c=TBL[r][a];e.current_record=await dp.table(o).key(n).get().then((e=>e.data[0]));const i=[].concat(e.current_record[c].push(t),t);return e.updated_record=await dp.table(o).key(n).update({[c]:i}).then((e=>e.data[0])),e}catch(t){return e.error=t,Promise.reject(e)}}(e,t))),await Promise.allSettled(e.connections);const r=e.connections.filter((e=>"error"in e)).map((e=>e.error));if(r.length)throw new AggregateError(r,"Update Error");return e}catch(t){return e.error=t,Promise.reject(e)}}(e)),e))),await Promise.allsettled(n);const o=n.filter((e=>"error"in e)).map((e=>e.error));if(o.length)throw new AggregateError(o,"Restoration Error");return Knack.hideSpinner(),n}catch(e){return Knack.hideSpinner(),MsgBox("There were error(s) restoring the archive",e.message),Promise.reject(archives)}}};async function e(t,r){const a=TBL[t].attributes.connections.inbound.filter((e=>"one"==e.has&&TBL[e.object].fields.models.some((e=>"Archived"===e.attributes.name)))).map((async e=>({table:TBL[e.object],archived_records:await dp.table(e.object).filter(e.key,"is",r.id).get("raw")}))),n=TBL[t].attributes.connections.outbound.filter((e=>"one"==e.has&&"one"==e.belongs_to)).map((async e=>({table:TBL[e.object],archived_records:await devicePixelRatio.table(e.object).key(r[e.key]).get("raw")})));let o=await Promise.all([...a,...n]);o=o.flatMap((e=>e.archived_records.map((t=>({table:e.table,archived_record:t})))));const c=new Set;o=o.filter((e=>{const t=e.archived_record.id,r=c.has(t);return c.add(t),!r}));let i=o.map((async t=>e(TBL[t.table],t.archived_record)));return o=o.map((async e=>async function(e){const t=TBL[e.table].attributes.connections.inbound;return e.connections=t.map((async t=>({table:TBL[t.object],field:FLD[t.object][t.key],records:await dp.table(t.object).filter(t.key,"is",e.archived_record.id).format("raw").getRecords()}))),e.connections=await Promise.all(e.connections),e.connections=e.connections.flatMap((e=>e.records.map((t=>({foreign_table:e.table,foreign_field:e.field,foreign_id:t.id}))))),e}(e))),o=await Promise.all(o),i=await Promise.all(i),o=[o,...i],o}};